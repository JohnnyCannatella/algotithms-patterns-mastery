# Technical Interview Vocabulary Guide

## Algorithm Analysis
### Time Complexity
- "The runtime complexity is..."
- "This solution runs in O(n) time"
- "The worst-case time complexity"
- "On average, this performs..."
- "The best-case scenario is..."
- "This algorithm scales linearly/quadratically"
- "Time-efficient approach"
- "Performance bottleneck"
- "Computational overhead"

### Space Complexity
- "The space complexity is..."
- "This requires O(n) extra space"
- "Memory-efficient solution"
- "In-place modification"
- "Auxiliary space needed"
- "Space optimization"
- "Memory footprint"

## Problem-Solving Approach
### Initial Analysis
- "Let me break this down..."
- "To understand the problem better..."
- "The key constraints are..."
- "Let's consider the edge cases..."
- "The input boundaries are..."
- "Some important considerations..."
- "Let me clarify the requirements"
- "Let's validate the assumptions"

### Solution Design
- "We could approach this by..."
- "One way to solve this is..."
- "Let's start with a naive solution"
- "We can optimize this further by..."
- "A more efficient approach would be..."
- "Let's consider trade-offs"
- "We might need to balance between..."
- "Let's explore alternative solutions"

## Data Structures
### Arrays and Strings
- "Contiguous memory allocation"
- "Index-based access"
- "Array traversal"
- "String manipulation"
- "Character frequency"
- "Substring operations"
- "Array slicing"
- "Two-pointer technique"

### Linked Lists
- "Node structure"
- "Pointer manipulation"
- "Head/tail references"
- "Linked list traversal"
- "Next pointer"
- "Previous reference"
- "Cycle detection"
- "List modification"

### Trees and Graphs
- "Root node"
- "Leaf nodes"
- "Tree traversal"
- "Depth-first search"
- "Breadth-first search"
- "Graph connectivity"
- "Adjacent vertices"
- "Tree balancing"
- "Node insertion/deletion"

### Hash Tables
- "Hash function"
- "Collision resolution"
- "Load factor"
- "Bucket array"
- "Key-value pairs"
- "Hash table resizing"
- "Constant-time lookup"
- "Hash collision"

## Common Patterns
### Iteration and Recursion
- "Base case"
- "Recursive call"
- "Stack overflow"
- "Iterative approach"
- "Recursive solution"
- "Call stack"
- "Tail recursion"
- "Iteration bounds"

### Dynamic Programming
- "Memoization"
- "Bottom-up approach"
- "Top-down solution"
- "Overlapping subproblems"
- "Optimal substructure"
- "State transition"
- "DP table"
- "Recurrence relation"

### System Design
- "Scalability"
- "Load balancing"
- "Caching strategy"
- "Database sharding"
- "Microservices architecture"
- "API design"
- "Fault tolerance"
- "High availability"
- "Consistency model"
- "Latency requirements"

## Code Quality
### Testing
- "Unit tests"
- "Edge case coverage"
- "Test scenarios"
- "Input validation"
- "Error handling"
- "Boundary testing"
- "Test-driven development"
- "Integration testing"

### Code Organization
- "Clean code"
- "Code modularity"
- "Design patterns"
- "SOLID principles"
- "Code reusability"
- "Maintainable solution"
- "Separation of concerns"
- "Single responsibility"

### Performance
- "Performance optimization"
- "Resource utilization"
- "Memory management"
- "CPU-bound"
- "I/O-bound"
- "Throughput"
- "Response time"
- "Caching strategy"

## Problem Types
### Search and Sort
- "Binary search"
- "Quick sort"
- "Merge sort"
- "Linear search"
- "Sorting algorithm"
- "Search space"
- "Divide and conquer"
- "Partition scheme"

### Graph Problems
- "Shortest path"
- "Minimum spanning tree"
- "Topological sort"
- "Connected components"
- "Cycle detection"
- "Path finding"
- "Graph traversal"
- "Vertex coloring"

### Mathematical Problems
- "Mathematical induction"
- "Number theory"
- "Probability calculation"
- "Geometric approach"
- "Linear algebra"
- "Statistical analysis"
- "Numerical computation"
- "Combinatorics"

## Communication Skills
### Clarification
- "To clarify..."
- "Let me confirm..."
- "Am I understanding correctly..."
- "Could you please explain..."
- "Just to verify..."
- "Let me rephrase..."

### Progress Updates
- "My current thinking is..."
- "So far, I've..."
- "The next step would be..."
- "I'm considering..."
- "Let me walk you through..."
- "Here's my approach..."

### Problem Resolution
- "One potential solution..."
- "We could improve this by..."
- "An alternative approach..."
- "The trade-off here is..."
- "This might be more efficient..."
- "Let's consider the implications..."

## Best Practices Tips
- Always verbalize your thought process
- Use precise technical terminology
- Explain trade-offs clearly
- Acknowledge alternative approaches
- Ask clarifying questions early
- Discuss complexity analysis proactively
- Mention potential optimizations
- Consider edge cases explicitly
- Explain your testing strategy
- Discuss scalability implications